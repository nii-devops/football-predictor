# requirements.txt
Flask==2.3.3
Flask-SQLAlchemy==3.0.5
Flask-WTF==1.1.1
Flask-Login==0.6.3
WTForms==3.0.1
Authlib==1.2.1
requests==2.31.0
python-dotenv==1.0.0



# config.py
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key'
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or 'sqlite:///epl_predictions.db'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    
    # Google OAuth
    GOOGLE_CLIENT_ID = os.environ.get('GOOGLE_CLIENT_ID')
    GOOGLE_CLIENT_SECRET = os.environ.get('GOOGLE_CLIENT_SECRET')
    
    # File uploads
    MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB
    UPLOAD_FOLDER = 'uploads'

class DevelopmentConfig(Config):
    DEBUG = True

class ProductionConfig(Config):
    DEBUG = False

config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}

# run.py
from app import app, db
from flask_migrate import Migrate

migrate = Migrate(app, db)

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)

# sky_sports_api.py - Sky Sports API Integration
import requests
from datetime import datetime, timedelta
from typing import List, Dict, Optional

class SkyResponseData:
    """Mock Sky Sports API response data structure"""
    
    @staticmethod
    def get_mock_fixtures() -> List[Dict]:
        """
        Mock fixtures data - replace with actual Sky Sports API integration
        """
        base_date = datetime.now() + timedelta(days=7)
        
        mock_fixtures = [
            {
                'homeTeam': {'name': 'Arsenal'},
                'awayTeam': {'name': 'Manchester United'},
                'kickoff': (base_date + timedelta(hours=0)).isoformat(),
                'status': 'FIXTURE'
            },
            {
                'homeTeam': {'name': 'Chelsea'},
                'awayTeam': {'name': 'Liverpool'},
                'kickoff': (base_date + timedelta(hours=2)).isoformat(),
                'status': 'FIXTURE'
            },
            {
                'homeTeam': {'name': 'Manchester City'},
                'awayTeam': {'name': 'Tottenham Hotspur'},
                'kickoff': (base_date + timedelta(days=1)).isoformat(),
                'status': 'FIXTURE'
            },
            {
                'homeTeam': {'name': 'Newcastle United'},
                'awayTeam': {'name': 'Brighton & Hove Albion'},
                'kickoff': (base_date + timedelta(days=1, hours=2)).isoformat(),
                'status': 'FIXTURE'
            },
            {
                'homeTeam': {'name': 'Aston Villa'},
                'awayTeam': {'name': 'West Ham United'},
                'kickoff': (base_date + timedelta(days=1, hours=4)).isoformat(),
                'status': 'FIXTURE'
            }
        ]
        
        return mock_fixtures

class SkyServicesAPI:
    """
    Sky Sports API Service Class
    
    This is a mock implementation. For production use, you would need to:
    1. Register for Sky Sports API access
    2. Get API credentials
    3. Implement proper authentication
    4. Handle rate limiting
    5. Parse actual response format
    """
    
    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key
        self.base_url = "https://api.skysports.com/v1"  # Mock URL
        
    def get_premier_league_fixtures(self, weeks_ahead: int = 2) -> List[Dict]:
        """
        Get Premier League fixtures for the next few weeks
        
        Args:
            weeks_ahead: Number of weeks to fetch fixtures for
            
        Returns:
            List of fixture dictionaries
        """
        
        # In production, this would make an actual API call:
        # response = requests.get(
        #     f"{self.base_url}/football/competitions/premier-league/fixtures",
        #     headers={'Authorization': f'Bearer {self.api_key}'},
        #     params={'weeks': weeks_ahead}
        # )
        
        # For now, return mock data
        return SkyResponseData.get_mock_fixtures()
    
    def parse_fixtures(self, raw_fixtures: List[Dict]) -> List[Dict]:
        """
        Parse raw fixture data into our application format
        
        Args:
            raw_fixtures: Raw fixture data from API
            
        Returns:
            Parsed fixture data
        """
        parsed_fixtures = []
        
        for fixture in raw_fixtures:
            try:
                parsed_fixture = {
                    'home_team': fixture['homeTeam']['name'],
                    'away_team': fixture['awayTeam']['name'],
                    'match_datetime': datetime.fromisoformat(fixture['kickoff'].replace('Z', '+00:00')),
                    'status': fixture.get('status', 'FIXTURE')
                }
                parsed_fixtures.append(parsed_fixture)
            except (KeyError, ValueError) as e:
                print(f"Error parsing fixture: {e}")
                continue
                
        return parsed_fixtures

# points_calculator.py - Points calculation system
class PointsCalculator:
    """Calculate points for predictions based on various scoring systems"""
    
    # Standard scoring system
    EXACT_SCORE_POINTS = 5
    CORRECT_RESULT_POINTS = 3
    CORRECT_GOAL_DIFFERENCE_POINTS = 1
    
    @classmethod
    def calculate_points(cls, prediction, actual_home_score, actual_away_score):
        """
        Calculate points for a prediction
        
        Args:
            prediction: Prediction object with home_score_prediction and away_score_prediction
            actual_home_score: Actual home team score
            actual_away_score: Actual away team score
            
        Returns:
            Points earned for this prediction
        """
        if actual_home_score is None or actual_away_score is None:
            return 0
            
        predicted_home = prediction.home_score_prediction
        predicted_away = prediction.away_score_prediction
        
        # Exact score match
        if predicted_home == actual_home_score and predicted_away == actual_away_score:
            return cls.EXACT_SCORE_POINTS
            
        # Correct result (win/draw/loss)
        predicted_result = cls._get_result(predicted_home, predicted_away)
        actual_result = cls._get_result(actual_home_score, actual_away_score)
        
        if predicted_result == actual_result:
            # Check for correct goal difference
            predicted_diff = predicted_home - predicted_away
            actual_diff = actual_home_score - actual_away_score
            
            if predicted_diff == actual_diff:
                return cls.CORRECT_RESULT_POINTS + cls.CORRECT_GOAL_DIFFERENCE_POINTS
            else:
                return cls.CORRECT_RESULT_POINTS
                
        return 0
    
    @staticmethod
    def _get_result(home_score, away_score):
        """Get result character (H/A/D) for given scores"""
        if home_score > away_score:
            return 'H'
        elif away_score > home_score:
            return 'A'
        else:
            return 'D'

# admin_utils.py - Admin utility functions
from datetime import datetime, timedelta
from app import db, MatchWeek, Fixture, Prediction
from sky_sports_api import SkyServicesAPI
from points_calculator import PointsCalculator

class AdminUtils:
    """Utility functions for admin operations"""
    
    @staticmethod
    def import_fixtures_from_sky_sports():
        """Import fixtures from Sky Sports API"""
        try:
            api = SkyServicesAPI()
            raw_fixtures = api.get_premier_league_fixtures()
            parsed_fixtures = api.parse_fixtures(raw_fixtures)
            
            # Group fixtures by week (simple logic - you might want more sophisticated grouping)
            current_week = AdminUtils.get_or_create_current_week()
            
            imported_count = 0
            for fixture_data in parsed_fixtures:
                # Check if fixture already exists
                existing_fixture = Fixture.query.filter_by(
                    home_team=fixture_data['home_team'],
                    away_team=fixture_data['away_team'],
                    match_datetime=fixture_data['match_datetime']
                ).first()
                
                if not existing_fixture:
                    fixture = Fixture(
                        match_week_id=current_week.id,
                        home_team=fixture_data['home_team'],
                        away_team=fixture_data['away_team'],
                        match_datetime=fixture_data['match_datetime']
                    )
                    db.session.add(fixture)
                    imported_count += 1
            
            db.session.commit()
            return imported_count
            
        except Exception as e:
            db.session.rollback()
            raise e
    
    @staticmethod
    def get_or_create_current_week():
        """Get or create a match week for current fixtures"""
        # Simple logic - create a match week for "Next Fixtures"
        week = MatchWeek.query.filter_by(name="Imported Fixtures").first()
        
        if not week:
            week = MatchWeek(
                week_number=99,  # Special week number for imported fixtures
                name="Imported Fixtures",
                predictions_open_time=datetime.utcnow(),
                predictions_close_time=datetime.utcnow() + timedelta(days=7)
            )
            db.session.add(week)
            db.session.flush()
            
        return week
    
    @staticmethod
    def update_fixture_results(fixture_id, home_score, away_score):
        """Update fixture results and calculate points for all predictions"""
        fixture = Fixture.query.get(fixture_id)
        if not fixture:
            raise ValueError("Fixture not found")
            
        # Update fixture results
        fixture.home_score = home_score
        fixture.away_score = away_score
        fixture.is_completed = True
        
        # Calculate points for all predictions on this fixture
        predictions = Prediction.query.filter_by(fixture_id=fixture_id).all()
        
        for prediction in predictions:
            points = PointsCalculator.calculate_points(prediction, home_score, away_score)
            prediction.points_earned = points
        
        db.session.commit()
        return len(predictions)

# Database initialization script
# init_db.py
from app import app, db, User
from werkzeug.security import generate_password_hash

def init_database():
    """Initialize database with tables and sample data"""
    
    with app.app_context():
        # Create all tables
        db.create_all()
        
        # Create sample admin user
        admin_user = User.query.filter_by(email='admin@example.com').first()
        if not admin_user:
            admin_user = User(
                email='admin@example.com',
                name='Admin User',
                google_id='sample_admin_123',
                is_admin=True
            )
            db.session.add(admin_user)
        
        db.session.commit()
        print("Database initialized successfully!")

if __name__ == '__main__':
    init_database()

# README.md content for setup instructions
"""
# EPL Match Predictions Flask App

A comprehensive Flask web application for predicting English Premier League match results with Google authentication, dynamic fixture management, and leaderboard functionality.

## Features

- üîê Google OAuth2 Authentication
- üìä Admin Dashboard for fixture management
- üèÜ Dynamic FlaskForm for creating match weeks with multiple fixtures
- üì± Responsive Bootstrap UI
- ü•á Leaderboard with points system
- üîÑ Sky Sports API integration (mock implementation)
- üìà Points calculation system

## Setup Instructions

### 1. Prerequisites
- Python 3.8+
- Google OAuth2 credentials
- Virtual environment (recommended)

### 2. Installation